{"version":3,"file":"react-query-hydration.production.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../src/hydration/hydration.ts","../src/react/QueryClientProvider.tsx","../src/hydration/react.tsx"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import type { QueryClient } from '../core/queryClient'\nimport type { Query, QueryState } from '../core/query'\nimport type {\n  MutationKey,\n  MutationOptions,\n  QueryKey,\n  QueryOptions,\n} from '../core/types'\nimport type { Mutation, MutationState } from '../core/mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  dehydrateMutations?: boolean\n  dehydrateQueries?: boolean\n  shouldDehydrateMutation?: ShouldDehydrateMutationFunction\n  shouldDehydrateQuery?: ShouldDehydrateQueryFunction\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport interface DehydratedState {\n  mutations: DehydratedMutation[]\n  queries: DehydratedQuery[]\n}\n\nexport type ShouldDehydrateQueryFunction = (query: Query) => boolean\n\nexport type ShouldDehydrateMutationFunction = (mutation: Mutation) => boolean\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n  }\n}\n\nfunction defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nfunction defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options?: DehydrateOptions\n): DehydratedState {\n  options = options || {}\n\n  const mutations: DehydratedMutation[] = []\n  const queries: DehydratedQuery[] = []\n\n  if (options?.dehydrateMutations !== false) {\n    const shouldDehydrateMutation =\n      options.shouldDehydrateMutation || defaultShouldDehydrateMutation\n\n    client\n      .getMutationCache()\n      .getAll()\n      .forEach(mutation => {\n        if (shouldDehydrateMutation(mutation)) {\n          mutations.push(dehydrateMutation(mutation))\n        }\n      })\n  }\n\n  if (options?.dehydrateQueries !== false) {\n    const shouldDehydrateQuery =\n      options.shouldDehydrateQuery || defaultShouldDehydrateQuery\n\n    client\n      .getQueryCache()\n      .getAll()\n      .forEach(query => {\n        if (shouldDehydrateQuery(query)) {\n          queries.push(dehydrateQuery(query))\n        }\n      })\n  }\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach(dehydratedMutation => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n      },\n      dehydratedMutation.state\n    )\n  })\n\n  queries.forEach(dehydratedQuery => {\n    const query = queryCache.get(dehydratedQuery.queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey: dehydratedQuery.queryKey,\n        queryHash: dehydratedQuery.queryHash,\n      },\n      dehydratedQuery.state\n    )\n  })\n}\n","import React from 'react'\n\nimport { QueryClient } from '../core'\n\nconst QueryClientContext = (() => {\n  const context = React.createContext<QueryClient | undefined>(undefined)\n  if (typeof window !== 'undefined') {\n    // @ts-ignore\n    window.ReactQueryClientContext = context\n  }\n  return context\n})()\n\nfunction getQueryClientContext() {\n  return typeof window !== 'undefined'\n    ? // @ts-ignore\n      (window.ReactQueryClientContext as React.Context<\n        QueryClient | undefined\n      >) ?? QueryClientContext\n    : QueryClientContext\n}\n\nexport const useQueryClient = () => {\n  const queryClient = React.useContext(getQueryClientContext())\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\nexport interface QueryClientProviderProps {\n  client: QueryClient\n}\n\nexport const QueryClientProvider: React.FC<QueryClientProviderProps> = ({\n  client,\n  children,\n}) => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  const Context = getQueryClientContext()\n\n  return <Context.Provider value={client}>{children}</Context.Provider>\n}\n","import React from 'react'\n\nimport { useQueryClient } from '../react'\nimport { hydrate, HydrateOptions } from './hydration'\n\nexport function useHydrate(state: unknown, options?: HydrateOptions) {\n  const queryClient = useQueryClient()\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization\n  React.useMemo(() => {\n    if (state) {\n      hydrate(queryClient, state, optionsRef.current)\n    }\n  }, [queryClient, state])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n  options?: HydrateOptions\n}\n\nexport const Hydrate: React.FC<HydrateProps> = ({\n  children,\n  options,\n  state,\n}) => {\n  useHydrate(state, options)\n  return children as React.ReactElement<any>\n}\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","defaultShouldDehydrateMutation","mutation","state","isPaused","defaultShouldDehydrateQuery","query","status","hydrate","client","dehydratedState","options","mutationCache","getMutationCache","queryCache","getQueryCache","mutations","queries","forEach","dehydratedMutation","build","defaultOptions","_options$defaultOptio","mutationKey","dehydratedQuery","get","queryHash","dataUpdatedAt","setState","_options$defaultOptio2","queryKey","context","QueryClientContext","React","createContext","undefined","window","ReactQueryClientContext","useQueryClient","queryClient","useContext","Error","useHydrate","optionsRef","useRef","current","useMemo","children","dehydrateMutations","shouldDehydrateMutation","getAll","push","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","dehydrateQuery"],"mappings":"oPAAe,SAASA,WACtBA,EAAWC,OAAOC,QAAU,SAAUC,OAC/B,IAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,KACrCG,EAASF,UAAUD,OAElB,IAAII,KAAOD,EACVN,OAAOQ,UAAUC,eAAeC,KAAKJ,EAAQC,KAC/CL,EAAOK,GAAOD,EAAOC,WAKpBL,IAGOS,MAAMC,KAAMR,WCoD9B,SAASS,EAA+BC,UAC/BA,EAASC,MAAMC,SAGxB,SAASC,EAA4BC,SACL,YAAvBA,EAAMH,MAAMI,OA2Cd,SAASC,EACdC,EACAC,EACAC,MAE+B,iBAApBD,GAAoD,OAApBA,OAIrCE,EAAgBH,EAAOI,mBACvBC,EAAaL,EAAOM,gBAEpBC,EAAaN,EAAoCM,WAAa,GAC9DC,EAAWP,EAAoCO,SAAW,GAEhED,EAAUE,SAAQ,SAAAC,SAChBP,EAAcQ,MACZX,aAEKE,YAAAA,EAASU,uBAATC,EAAyBN,WAC5BO,YAAaJ,EAAmBI,cAElCJ,EAAmBhB,UAIvBc,EAAQC,SAAQ,SAAAM,SACRlB,EAAQQ,EAAWW,IAAID,EAAgBE,WAGzCpB,EACEA,EAAMH,MAAMwB,cAAgBH,EAAgBrB,MAAMwB,eACpDrB,EAAMsB,SAASJ,EAAgBrB,OAMnCW,EAAWM,MACTX,aAEKE,YAAAA,EAASU,uBAATQ,EAAyBZ,SAC5Ba,SAAUN,EAAgBM,SAC1BJ,UAAWF,EAAgBE,YAE7BF,EAAgBrB,8EC5JtB,IACQ4B,EADFC,GACED,EAAUE,EAAMC,mBAAuCC,GACvC,oBAAXC,SAETA,OAAOC,wBAA0BN,GAE5BA,GAYF,IAAMO,EAAiB,iBACtBC,EAAcN,EAAMO,WATD,oBAAXJ,iBAETA,OAAOC,2BAGRL,OAMCO,QACG,IAAIE,MAAM,iEAGXF,GCxBF,SAASG,EAAWvC,EAAgBQ,OACnC4B,EAAcD,IAEdK,EAAaV,EAAMW,OAAOjC,GAChCgC,EAAWE,QAAUlC,EAKrBsB,EAAMa,SAAQ,WACR3C,GACFK,EAAQ+B,EAAapC,EAAOwC,EAAWE,WAExC,CAACN,EAAapC,cAQ4B,gBAC7C4C,IAAAA,SACApC,IAAAA,eAGA+B,IAFAvC,MAEkBQ,GACXoC,eF2CF,SACLtC,EACAE,WAIMK,EAAkC,GAClCC,EAA6B,OAEC,cALpCN,EAAUA,GAAW,aAKRqC,oBAA8B,KACnCC,EACJtC,EAAQsC,yBAA2BhD,EAErCQ,EACGI,mBACAqC,SACAhC,SAAQ,SAAAhB,GACH+C,EAAwB/C,IAC1Bc,EAAUmC,KA7CpB,SAA2BjD,SAClB,CACLqB,YAAarB,EAASS,QAAQY,YAC9BpB,MAAOD,EAASC,OA0CKiD,CAAkBlD,WAKP,cAA9BS,YAAS0C,kBAA4B,KACjCC,EACJ3C,EAAQ2C,sBAAwBjD,EAElCI,EACGM,gBACAmC,SACAhC,SAAQ,SAAAZ,GACHgD,EAAqBhD,IACvBW,EAAQkC,KAhDlB,SAAwB7C,SACf,CACLH,MAAOG,EAAMH,MACb2B,SAAUxB,EAAMwB,SAChBJ,UAAWpB,EAAMoB,WA4CE6B,CAAejD,aAK7B,CAAEU,UAAAA,EAAWC,QAAAA"}