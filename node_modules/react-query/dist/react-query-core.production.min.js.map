{"version":3,"file":"react-query-core.production.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../node_modules/@babel/runtime/helpers/esm/extends.js","../src/core/utils.ts","../src/core/notifyManager.ts","../src/core/logger.ts","../src/core/subscribable.ts","../src/core/focusManager.ts","../src/core/onlineManager.ts","../src/core/retryer.ts","../src/core/query.ts","../src/core/queryCache.ts","../src/core/mutation.ts","../src/core/mutationCache.ts","../src/core/infiniteQueryBehavior.ts","../src/core/queryClient.ts","../src/core/queryObserver.ts","../src/core/queriesObserver.ts","../src/core/infiniteQueryObserver.ts","../src/core/mutationObserver.ts"],"sourcesContent":["export default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}","export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import type { Query } from './query'\nimport type {\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryKeyHashFunction,\n  QueryOptions,\n  QueryStatus,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Include or exclude active queries\n   */\n  active?: boolean\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include or exclude inactive queries\n   */\n  inactive?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include or exclude fetching queries\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined'\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: any): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function ensureArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value]\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter(x => array2.indexOf(x) === -1)\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<TOptions extends QueryOptions<any, any, any>>(\n  arg1: QueryKey | TOptions,\n  arg2?: QueryFunction<any> | TOptions,\n  arg3?: TOptions\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions\n): [TFilters, TOptions | undefined] {\n  return (isQueryKey(arg1)\n    ? [{ ...arg2, queryKey: arg1 }, arg3]\n    : [arg1 || {}, arg2]) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any>\n): boolean {\n  const {\n    active,\n    exact,\n    fetching,\n    inactive,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      const hashFn = getQueryKeyHashFn(query.options)\n      if (query.queryHash !== hashFn(queryKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  let isActive\n\n  if (inactive === false || (active && !inactive)) {\n    isActive = true\n  } else if (active === false || (inactive && !active)) {\n    isActive = false\n  }\n\n  if (typeof isActive === 'boolean' && query.isActive() !== isActive) {\n    return false\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (typeof fetching === 'boolean' && query.isFetching() !== fetching) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function getQueryKeyHashFn(\n  options?: QueryOptions<any, any>\n): QueryKeyHashFunction {\n  return options?.queryKeyHashFn || hashQueryKey\n}\n\n/**\n * Default query keys hash function.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return stableValueHash(queryKey)\n}\n\n/**\n * Hashes the value into a stable hash.\n */\nexport function stableValueHash(value: any): string {\n  return JSON.stringify(value, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(\n  a: string | unknown[],\n  b: string | unknown[]\n): boolean {\n  return partialDeepEqual(ensureArray(a), ensureArray(b))\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = Array.isArray(a) && Array.isArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: any): value is QueryKey {\n  return typeof value === 'string' || Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function getStatusProps<T extends QueryStatus>(status: T) {\n  return {\n    status,\n    isLoading: status === 'loading',\n    isSuccess: status === 'success',\n    isError: status === 'error',\n    isIdle: status === 'idle',\n  }\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void): void {\n  Promise.resolve()\n    .then(callback)\n    .catch(error =>\n      setTimeout(() => {\n        throw error\n      })\n    )\n}\n","import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\n// CLASS\n\nclass NotifyManager {\n  private queue: NotifyCallback[]\n  private transactions: number\n  private notifyFn: NotifyFunction\n  private batchNotifyFn: BatchNotifyFunction\n\n  constructor() {\n    this.queue = []\n    this.transactions = 0\n\n    this.notifyFn = (callback: () => void) => {\n      callback()\n    }\n\n    this.batchNotifyFn = (callback: () => void) => {\n      callback()\n    }\n  }\n\n  batch<T>(callback: () => T): T {\n    this.transactions++\n    const result = callback()\n    this.transactions--\n    if (!this.transactions) {\n      this.flush()\n    }\n    return result\n  }\n\n  schedule(callback: NotifyCallback): void {\n    if (this.transactions) {\n      this.queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        this.notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  batchCalls<T extends Function>(callback: T): T {\n    return ((...args: any[]) => {\n      this.schedule(() => {\n        callback(...args)\n      })\n    }) as any\n  }\n\n  flush(): void {\n    const queue = this.queue\n    this.queue = []\n    if (queue.length) {\n      scheduleMicrotask(() => {\n        this.batchNotifyFn(() => {\n          queue.forEach(callback => {\n            this.notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  setNotifyFunction(fn: NotifyFunction) {\n    this.notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  setBatchNotifyFunction(fn: BatchNotifyFunction) {\n    this.batchNotifyFn = fn\n  }\n}\n\n// SINGLETON\n\nexport const notifyManager = new NotifyManager()\n","import { noop } from './utils'\n\n// TYPES\n\nexport interface Logger {\n  log: LogFunction\n  warn: LogFunction\n  error: LogFunction\n}\n\ntype LogFunction = (...args: any[]) => void\n\n// FUNCTIONS\n\nlet logger: Logger = console || {\n  error: noop,\n  warn: noop,\n  log: noop,\n}\n\nexport function getLogger(): Logger {\n  return logger\n}\n\nexport function setLogger(newLogger: Logger) {\n  logger = newLogger\n}\n","type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: TListener[]\n\n  constructor() {\n    this.listeners = []\n  }\n\n  subscribe(listener?: TListener): () => void {\n    const callback = listener || (() => undefined)\n\n    this.listeners.push(callback as TListener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== callback)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.length > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\nclass FocusManager extends Subscribable {\n  private focused?: boolean\n  private removeEventListener?: () => void\n\n  protected onSubscribe(): void {\n    if (!this.removeEventListener) {\n      this.setDefaultEventListener()\n    }\n  }\n\n  setEventListener(\n    setup: (onFocus: () => void) => (focused?: boolean) => void\n  ): void {\n    if (this.removeEventListener) {\n      this.removeEventListener()\n    }\n    this.removeEventListener = setup((focused?: boolean) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    this.focused = focused\n\n    if (focused) {\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach(listener => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState\n    )\n  }\n\n  private setDefaultEventListener() {\n    if (!isServer && window?.addEventListener) {\n      this.setEventListener(onFocus => {\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', onFocus, false)\n        window.addEventListener('focus', onFocus, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', onFocus)\n          window.removeEventListener('focus', onFocus)\n        }\n      })\n    }\n  }\n}\n\nexport const focusManager = new FocusManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\nclass OnlineManager extends Subscribable {\n  private online?: boolean\n  private removeEventListener?: () => void\n\n  protected onSubscribe(): void {\n    if (!this.removeEventListener) {\n      this.setDefaultEventListener()\n    }\n  }\n\n  setEventListener(\n    setup: (setOnline: () => void) => (online?: boolean) => void\n  ): void {\n    if (this.removeEventListener) {\n      this.removeEventListener()\n    }\n    this.removeEventListener = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    this.online = online\n\n    if (online) {\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach(listener => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    return navigator.onLine === undefined || navigator.onLine\n  }\n\n  private setDefaultEventListener() {\n    if (!isServer && window?.addEventListener) {\n      this.setEventListener(onOnline => {\n        // Listen to online\n        window.addEventListener('online', onOnline, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', onOnline)\n        }\n      })\n    }\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { functionalUpdate, sleep } from './utils'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError\n) => boolean\n\nexport type RetryDelayValue = number | RetryDelayFunction\n\ntype RetryDelayFunction = (failureCount: number) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\ninterface Cancelable {\n  cancel(): void\n}\n\nexport function isCancelable(value: any): value is Cancelable {\n  return typeof value?.cancel === 'function'\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\n// CLASS\n\nexport class Retryer<TData = unknown, TError = unknown> {\n  cancel: (options?: CancelOptions) => void\n  cancelRetry: () => void\n  continue: () => void\n  failureCount: number\n  isPaused: boolean\n  isResolved: boolean\n  isTransportCancelable: boolean\n  promise: Promise<TData>\n\n  constructor(config: RetryerConfig<TData, TError>) {\n    let cancelRetry = false\n    let cancelFn: ((options?: CancelOptions) => void) | undefined\n    let continueFn: ((value?: unknown) => void) | undefined\n    let promiseResolve: (data: TData) => void\n    let promiseReject: (error: TError) => void\n\n    this.cancel = cancelOptions => cancelFn?.(cancelOptions)\n    this.cancelRetry = () => {\n      cancelRetry = true\n    }\n    this.continue = () => continueFn?.()\n    this.failureCount = 0\n    this.isPaused = false\n    this.isResolved = false\n    this.isTransportCancelable = false\n    this.promise = new Promise<TData>((outerResolve, outerReject) => {\n      promiseResolve = outerResolve\n      promiseReject = outerReject\n    })\n\n    const resolve = (value: any) => {\n      this.isResolved = true\n      continueFn?.()\n      promiseResolve(value)\n    }\n\n    const reject = (value: any) => {\n      this.isResolved = true\n      continueFn?.()\n      promiseReject(value)\n    }\n\n    const pause = () => {\n      return new Promise(continueResolve => {\n        continueFn = continueResolve\n        this.isPaused = true\n        config.onPause?.()\n      }).then(() => {\n        continueFn = undefined\n        this.isPaused = false\n        config.onContinue?.()\n      })\n    }\n\n    // Create loop function\n    const run = () => {\n      // Do nothing if already resolved\n      if (this.isResolved) {\n        return\n      }\n\n      let promiseOrValue: any\n\n      // Execute query\n      try {\n        promiseOrValue = config.fn()\n      } catch (error) {\n        promiseOrValue = Promise.reject(error)\n      }\n\n      // Create callback to cancel this fetch\n      cancelFn = cancelOptions => {\n        reject(new CancelledError(cancelOptions))\n\n        // Cancel transport if supported\n        if (isCancelable(promiseOrValue)) {\n          try {\n            promiseOrValue.cancel()\n          } catch {}\n        }\n      }\n\n      // Check if the transport layer support cancellation\n      this.isTransportCancelable = isCancelable(promiseOrValue)\n\n      Promise.resolve(promiseOrValue)\n        .then(resolve)\n        .catch(error => {\n          // Stop if the fetch is already resolved\n          if (this.isResolved) {\n            return\n          }\n\n          // Do we need to retry the request?\n          const retry = config.retry ?? 3\n          const retryDelay = config.retryDelay ?? defaultRetryDelay\n          const delay = functionalUpdate(retryDelay, this.failureCount) || 0\n          const shouldRetry =\n            retry === true ||\n            (typeof retry === 'number' && this.failureCount < retry) ||\n            (typeof retry === 'function' && retry(this.failureCount, error))\n\n          if (cancelRetry || !shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error)\n            return\n          }\n\n          this.failureCount++\n\n          // Notify on fail\n          config.onFail?.(this.failureCount, error)\n\n          // Delay\n          sleep(delay)\n            // Pause if the document is not visible or when the device is offline\n            .then(() => {\n              if (!focusManager.isFocused() || !onlineManager.isOnline()) {\n                return pause()\n              }\n            })\n            .then(() => {\n              if (cancelRetry) {\n                reject(error)\n              } else {\n                run()\n              }\n            })\n        })\n    }\n\n    // Start loop\n    run()\n  }\n}\n","import {\n  Updater,\n  ensureArray,\n  functionalUpdate,\n  isValidTimeout,\n  noop,\n  replaceEqualDeep,\n  timeUntilStale,\n} from './utils'\nimport type {\n  InitialDataFunction,\n  QueryKey,\n  QueryOptions,\n  QueryStatus,\n  QueryFunctionContext,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport { notifyManager } from './notifyManager'\nimport { getLogger } from './logger'\nimport { Retryer, CancelOptions, isCancelledError } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<TQueryFnData, TError, TData> {\n  cache: QueryCache\n  queryKey: QueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchMeta: any\n  isFetching: boolean\n  isInvalidated: boolean\n  isPaused: boolean\n  status: QueryStatus\n}\n\nexport interface FetchContext<TQueryFnData, TError, TData> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  options: QueryOptions<TQueryFnData, TError, TData>\n  queryKey: QueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n> {\n  onFetch: (context: FetchContext<TQueryFnData, TError, TData>) => void\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: any\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\ninterface FailedAction {\n  type: 'failed'\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: any\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: QueryState<TData, TError>\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n> {\n  queryKey: QueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData>\n  initialState: QueryState<TData, TError>\n  state: QueryState<TData, TError>\n  cacheTime!: number\n\n  private cache: QueryCache\n  private promise?: Promise<TData>\n  private gcTimeout?: number\n  private retryer?: Retryer<unknown, TError>\n  private observers: QueryObserver<any, any, any, any>[]\n  private defaultOptions?: QueryOptions<TQueryFnData, TError, TData>\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData>) {\n    this.defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.cache = config.cache\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.initialState = config.state || this.getDefaultState(this.options)\n    this.state = this.initialState\n    this.scheduleGc()\n  }\n\n  private setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData>\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    // Default to 5 minutes if not cache time is set\n    this.cacheTime = Math.max(\n      this.cacheTime || 0,\n      this.options.cacheTime ?? 5 * 60 * 1000\n    )\n  }\n\n  setDefaultOptions(options: QueryOptions<TQueryFnData, TError, TData>): void {\n    this.defaultOptions = options\n  }\n\n  private scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.cacheTime)\n    }\n  }\n\n  private clearGcTimeout() {\n    clearTimeout(this.gcTimeout)\n    this.gcTimeout = undefined\n  }\n\n  private optionalRemove() {\n    if (!this.observers.length && !this.state.isFetching) {\n      this.cache.remove(this)\n    }\n  }\n\n  setData(\n    updater: Updater<TData | undefined, TData>,\n    options?: SetDataOptions\n  ): TData {\n    const prevData = this.state.data\n\n    // Get the new data\n    let data = functionalUpdate(updater, prevData)\n\n    // Use prev data if an isDataEqual function is defined and returns `true`\n    if (this.options.isDataEqual?.(prevData, data)) {\n      data = prevData as TData\n    } else if (this.options.structuralSharing !== false) {\n      // Structurally share data between prev and new data if needed\n      data = replaceEqualDeep(prevData, data)\n    }\n\n    // Set data and mark it as cached\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n    })\n\n    return data\n  }\n\n  setState(state: QueryState<TData, TError>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.promise\n    this.retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    this.clearGcTimeout()\n    this.cancel()\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(observer => observer.options.enabled !== false)\n  }\n\n  isFetching(): boolean {\n    return this.state.isFetching\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.observers.some(observer => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find(x => x.willFetchOnWindowFocus())\n\n    if (observer) {\n      observer.refetch()\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find(x => x.willFetchOnReconnect())\n\n    if (observer) {\n      observer.refetch()\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.cache.notify(this)\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.retryer.isTransportCancelable) {\n            this.retryer.cancel()\n          } else {\n            this.retryer.cancelRetry()\n          }\n        }\n\n        if (this.cacheTime) {\n          this.scheduleGc()\n        } else {\n          this.cache.remove(this)\n        }\n      }\n\n      this.cache.notify(this)\n    }\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData>,\n    fetchOptions?: FetchOptions\n  ): Promise<TData> {\n    if (this.state.isFetching)\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.promise) {\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    // Create query function context\n    const queryKey = ensureArray(this.queryKey)\n    const queryFnContext: QueryFunctionContext = {\n      queryKey,\n      pageParam: undefined,\n    }\n\n    // Create fetch function\n    const fetchFn = () =>\n      this.options.queryFn\n        ? this.options.queryFn(queryFnContext)\n        : Promise.reject('Missing queryFn')\n\n    // Trigger behavior hook\n    const context: FetchContext<TQueryFnData, TError, TData> = {\n      fetchOptions,\n      options: this.options,\n      queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    if (this.options.behavior?.onFetch) {\n      this.options.behavior?.onFetch(context)\n    }\n\n    // Set to fetching state if not already in it\n    if (\n      !this.state.isFetching ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    // Try to fetch the data\n    this.retryer = new Retryer({\n      fn: context.fetchFn,\n      onFail: () => {\n        this.dispatch({ type: 'failed' })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n    })\n\n    this.promise = this.retryer.promise\n      .then(data => this.setData(data as TData))\n      .catch(error => {\n        // Set error state if needed\n        if (!(isCancelledError(error) && error.silent)) {\n          this.dispatch({\n            type: 'error',\n            error,\n          })\n        }\n\n        if (!isCancelledError(error)) {\n          // Notify cache callback\n          if (this.cache.config.onError) {\n            this.cache.config.onError(error, this as Query)\n          }\n\n          // Log error\n          getLogger().error(error)\n        }\n\n        // Remove query after fetching if cache time is 0\n        if (this.cacheTime === 0) {\n          this.optionalRemove()\n        }\n\n        // Propagate error\n        throw error\n      })\n      .then(data => {\n        // Remove query after fetching if cache time is 0\n        if (this.cacheTime === 0) {\n          this.optionalRemove()\n        }\n\n        return data\n      })\n\n    return this.promise\n  }\n\n  private dispatch(action: Action<TData, TError>): void {\n    this.state = this.reducer(this.state, action)\n\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action)\n      })\n\n      this.cache.notify(this)\n    })\n  }\n\n  protected getDefaultState(\n    options: QueryOptions<TQueryFnData, TError, TData>\n  ): QueryState<TData, TError> {\n    const data =\n      typeof options.initialData === 'function'\n        ? (options.initialData as InitialDataFunction<TData>)()\n        : options.initialData\n\n    const hasInitialData = typeof options.initialData !== 'undefined'\n\n    const initialDataUpdatedAt = hasInitialData\n      ? typeof options.initialDataUpdatedAt === 'function'\n        ? (options.initialDataUpdatedAt as () => number | undefined)()\n        : options.initialDataUpdatedAt\n      : 0\n\n    const hasData = typeof data !== 'undefined'\n\n    return {\n      data,\n      dataUpdateCount: 0,\n      dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n      error: null,\n      errorUpdateCount: 0,\n      errorUpdatedAt: 0,\n      fetchFailureCount: 0,\n      fetchMeta: null,\n      isFetching: false,\n      isInvalidated: false,\n      isPaused: false,\n      status: hasData ? 'success' : 'idle',\n    }\n  }\n\n  protected reducer(\n    state: QueryState<TData, TError>,\n    action: Action<TData, TError>\n  ): QueryState<TData, TError> {\n    switch (action.type) {\n      case 'failed':\n        return {\n          ...state,\n          fetchFailureCount: state.fetchFailureCount + 1,\n        }\n      case 'pause':\n        return {\n          ...state,\n          isPaused: true,\n        }\n      case 'continue':\n        return {\n          ...state,\n          isPaused: false,\n        }\n      case 'fetch':\n        return {\n          ...state,\n          fetchFailureCount: 0,\n          fetchMeta: action.meta ?? null,\n          isFetching: true,\n          isPaused: false,\n          status: !state.dataUpdatedAt ? 'loading' : state.status,\n        }\n      case 'success':\n        return {\n          ...state,\n          data: action.data,\n          dataUpdateCount: state.dataUpdateCount + 1,\n          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n          error: null,\n          fetchFailureCount: 0,\n          isFetching: false,\n          isInvalidated: false,\n          isPaused: false,\n          status: 'success',\n        }\n      case 'error':\n        const error = action.error as unknown\n\n        if (isCancelledError(error) && error.revert) {\n          let previousStatus: QueryStatus\n\n          if (!state.dataUpdatedAt && !state.errorUpdatedAt) {\n            previousStatus = 'idle'\n          } else if (state.dataUpdatedAt > state.errorUpdatedAt) {\n            previousStatus = 'success'\n          } else {\n            previousStatus = 'error'\n          }\n\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            isFetching: false,\n            isPaused: false,\n            status: previousStatus,\n          }\n        }\n\n        return {\n          ...state,\n          error: error as TError,\n          errorUpdateCount: state.errorUpdateCount + 1,\n          errorUpdatedAt: Date.now(),\n          fetchFailureCount: state.fetchFailureCount + 1,\n          isFetching: false,\n          isPaused: false,\n          status: 'error',\n        }\n      case 'invalidate':\n        return {\n          ...state,\n          isInvalidated: true,\n        }\n      case 'setState':\n        return {\n          ...state,\n          ...action.state,\n        }\n      default:\n        return state\n    }\n  }\n}\n","import {\n  QueryFilters,\n  getQueryKeyHashFn,\n  matchQuery,\n  parseFilterArgs,\n} from './utils'\nimport { Query, QueryState } from './query'\nimport type { QueryKey, QueryOptions } from './types'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (error: unknown, query: Query<unknown, unknown, unknown>) => void\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any>\n}\n\ntype QueryCacheListener = (query?: Query) => void\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  config: QueryCacheConfig\n\n  private queries: Query<any, any>[]\n  private queriesMap: QueryHashMap\n\n  constructor(config?: QueryCacheConfig) {\n    super()\n    this.config = config || {}\n    this.queries = []\n    this.queriesMap = {}\n  }\n\n  build<TQueryFnData, TError, TData>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData>,\n    state?: QueryState<TData, TError>\n  ): Query<TQueryFnData, TError, TData> {\n    const hashFn = getQueryKeyHashFn(options)\n    const queryKey = options.queryKey!\n    const queryHash = options.queryHash ?? hashFn(queryKey)\n    let query = this.get<TQueryFnData, TError, TData>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify(query)\n    }\n  }\n\n  remove(query: Query<any, any>): void {\n    const queryInMap = this.queriesMap[query.queryHash]\n\n    if (queryInMap) {\n      query.destroy()\n\n      this.queries = this.queries.filter(x => x !== query)\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash]\n      }\n\n      this.notify(query)\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryHash: string\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    return this.queriesMap[queryHash]\n  }\n\n  getAll(): Query[] {\n    return this.queries\n  }\n\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: QueryKey,\n    arg2?: QueryFilters\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return this.queries.find(query => matchQuery(filters, query))\n  }\n\n  findAll(queryKey?: QueryKey, filters?: QueryFilters): Query[]\n  findAll(filters?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[] {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return filters\n      ? this.queries.filter(query => matchQuery(filters, query))\n      : this.queries\n  }\n\n  notify(query?: Query<any, any>) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(query)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline()\n      })\n    })\n  }\n}\n","import type { MutationOptions, MutationStatus } from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport { getLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { Retryer } from './retryer'\nimport { noop } from './utils'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n}\n\ninterface FailedAction {\n  type: 'failed'\n}\n\ninterface LoadingAction<TVariables, TContext> {\n  type: 'loading'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError, TVariables, TContext> {\n  type: 'setState'\n  state: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction\n  | LoadingAction<TVariables, TContext>\n  | PauseAction\n  | SetStateAction<TData, TError, TVariables, TContext>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  mutationId: number\n\n  private observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  private mutationCache: MutationCache\n  private retryer?: Retryer<TData, TError>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    this.options = {\n      ...config.defaultOptions,\n      ...config.options,\n    }\n    this.mutationId = config.mutationId\n    this.mutationCache = config.mutationCache\n    this.observers = []\n    this.state = config.state || getDefaultState()\n  }\n\n  setState(state: MutationState<TData, TError, TVariables, TContext>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.observers = this.observers.filter(x => x !== observer)\n  }\n\n  cancel(): Promise<void> {\n    if (this.retryer) {\n      this.retryer.cancel()\n      return this.retryer.promise.then(noop).catch(noop)\n    }\n    return Promise.resolve()\n  }\n\n  continue(): Promise<TData> {\n    if (this.retryer) {\n      this.retryer.continue()\n      return this.retryer.promise\n    }\n    return this.execute()\n  }\n\n  execute(): Promise<TData> {\n    let data: TData\n\n    const restored = this.state.status === 'loading'\n\n    let promise = Promise.resolve()\n\n    if (!restored) {\n      this.dispatch({ type: 'loading', variables: this.options.variables! })\n      promise = promise\n        .then(() => this.options.onMutate?.(this.state.variables!))\n        .then(context => {\n          if (context !== this.state.context) {\n            this.dispatch({\n              type: 'loading',\n              context,\n              variables: this.state.variables,\n            })\n          }\n        })\n    }\n\n    return promise\n      .then(() => this.executeMutation())\n      .then(result => {\n        data = result\n      })\n      .then(() =>\n        this.options.onSuccess?.(\n          data,\n          this.state.variables!,\n          this.state.context!\n        )\n      )\n      .then(() =>\n        this.options.onSettled?.(\n          data,\n          null,\n          this.state.variables!,\n          this.state.context\n        )\n      )\n      .then(() => {\n        this.dispatch({ type: 'success', data })\n        return data\n      })\n      .catch(error => {\n        // Notify cache callback\n        if (this.mutationCache.config.onError) {\n          this.mutationCache.config.onError(\n            error,\n            this.state.variables,\n            this.state.context,\n            this as Mutation<unknown, unknown, unknown, unknown>\n          )\n        }\n\n        // Log error\n        getLogger().error(error)\n\n        return Promise.resolve()\n          .then(() =>\n            this.options.onError?.(\n              error,\n              this.state.variables!,\n              this.state.context\n            )\n          )\n          .then(() =>\n            this.options.onSettled?.(\n              undefined,\n              error,\n              this.state.variables!,\n              this.state.context\n            )\n          )\n          .then(() => {\n            this.dispatch({ type: 'error', error })\n            throw error\n          })\n      })\n  }\n\n  private executeMutation(): Promise<TData> {\n    this.retryer = new Retryer({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject('No mutationFn found')\n        }\n        return this.options.mutationFn(this.state.variables!)\n      },\n      onFail: () => {\n        this.dispatch({ type: 'failed' })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n    })\n\n    return this.retryer.promise\n  }\n\n  private dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    this.state = reducer(this.state, action)\n\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action)\n      })\n      this.mutationCache.notify(this)\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n  }\n}\n\nfunction reducer<TData, TError, TVariables, TContext>(\n  state: MutationState<TData, TError, TVariables, TContext>,\n  action: Action<TData, TError, TVariables, TContext>\n): MutationState<TData, TError, TVariables, TContext> {\n  switch (action.type) {\n    case 'failed':\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case 'pause':\n      return {\n        ...state,\n        isPaused: true,\n      }\n    case 'continue':\n      return {\n        ...state,\n        isPaused: false,\n      }\n    case 'loading':\n      return {\n        ...state,\n        context: action.context,\n        data: undefined,\n        error: null,\n        isPaused: false,\n        status: 'loading',\n        variables: action.variables,\n      }\n    case 'success':\n      return {\n        ...state,\n        data: action.data,\n        error: null,\n        status: 'success',\n        isPaused: false,\n      }\n    case 'error':\n      return {\n        ...state,\n        data: undefined,\n        error: action.error,\n        failureCount: state.failureCount + 1,\n        isPaused: false,\n        status: 'error',\n      }\n    case 'setState':\n      return {\n        ...state,\n        ...action.state,\n      }\n    default:\n      return state\n  }\n}\n","import type { MutationOptions } from './types'\nimport type { QueryClient } from './queryClient'\nimport { notifyManager } from './notifyManager'\nimport { Mutation, MutationState } from './mutation'\nimport { noop } from './utils'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown, unknown>\n  ) => void\n}\n\ntype MutationCacheListener = (mutation?: Mutation) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  config: MutationCacheConfig\n\n  private mutations: Mutation<any, any, any, any>[]\n  private mutationId: number\n\n  constructor(config?: MutationCacheConfig) {\n    super()\n    this.config = config || {}\n    this.mutations = []\n    this.mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey\n        ? client.getMutationDefaults(options.mutationKey)\n        : undefined,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.mutations.push(mutation)\n    this.notify(mutation)\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.mutations = this.mutations.filter(x => x !== mutation)\n    mutation.cancel()\n    this.notify(mutation)\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.mutations\n  }\n\n  notify(mutation?: Mutation<any, any, any, any>) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(mutation)\n      })\n    })\n  }\n\n  onFocus(): void {\n    this.resumePausedMutations()\n  }\n\n  onOnline(): void {\n    this.resumePausedMutations()\n  }\n\n  resumePausedMutations(): Promise<void> {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused)\n    return notifyManager.batch(() =>\n      pausedMutations.reduce(\n        (promise, mutation) =>\n          promise.then(() => mutation.continue().catch(noop)),\n        Promise.resolve()\n      )\n    )\n  }\n}\n","import type { QueryBehavior } from './query'\nimport { isCancelable } from './retryer'\nimport type { InfiniteData, QueryFunctionContext, QueryOptions } from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn || (() => Promise.reject('Missing queryFn'))\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean\n        ): Promise<unknown[]> => {\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n          }\n\n          let cancelFn: undefined | (() => any)\n          const queryFnResult = queryFn(queryFnContext)\n          if ((queryFnResult as any).cancel) {\n            cancelFn = (queryFnResult as any).cancel\n          }\n\n          const promise = Promise.resolve(queryFnResult).then(page => {\n            newPageParams = previous\n              ? [param, ...newPageParams]\n              : [...newPageParams, param]\n            return previous ? [page, ...pages] : [...pages, page]\n          })\n\n          if (cancelFn) {\n            const promiseAsAny = promise as any\n            promiseAsAny.cancel = cancelFn\n          }\n\n          return promise\n        }\n\n        let promise\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          // Fetch first page\n          promise = fetchPage([], manual, oldPageParams[0])\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const param = manual\n                ? oldPageParams[i]\n                : getNextPageParam(context.options, pages)\n              return fetchPage(pages, manual, param)\n            })\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        if (isCancelable(promise)) {\n          const finalPromiseAsAny = finalPromise as any\n          finalPromiseAsAny.cancel = promise.cancel\n        }\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[]\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[]\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any>,\n  pages?: unknown\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any>,\n  pages?: unknown\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n}\n","import {\n  QueryFilters,\n  Updater,\n  hashQueryKey,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n} from './utils'\nimport type {\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  ResetOptions,\n} from './types'\nimport type { QueryState, SetDataOptions } from './query'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { CancelOptions } from './retryer'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\n\n// TYPES\n\ninterface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n  }\n\n  mount(): void {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused() && onlineManager.isOnline()) {\n        this.mutationCache.onFocus()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (focusManager.isFocused() && onlineManager.isOnline()) {\n        this.mutationCache.onOnline()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.unsubscribeFocus?.()\n    this.unsubscribeOnline?.()\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKey, filters?: QueryFilters): number\n  isFetching(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetching = true\n    return this.queryCache.findAll(filters).length\n  }\n\n  getQueryData<TData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters\n  ): TData | undefined {\n    return this.queryCache.find<TData>(queryKey, filters)?.state.data\n  }\n\n  setQueryData<TData>(\n    queryKey: QueryKey,\n    updater: Updater<TData | undefined, TData>,\n    options?: SetDataOptions\n  ): TData {\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(updater, options)\n  }\n\n  getQueryState<TData = unknown, TError = undefined>(\n    queryKey: QueryKey,\n    filters?: QueryFilters\n  ): QueryState<TData, TError> | undefined {\n    return this.queryCache.find<TData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKey, filters?: QueryFilters): void\n  removeQueries(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries(filters?: QueryFilters, options?: ResetOptions): Promise<void>\n  resetQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: ResetOptions\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | ResetOptions,\n    arg3?: ResetOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: QueryFilters = {\n      ...filters,\n      active: true,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: CancelOptions\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions))\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries(\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions\n  ): Promise<void>\n  invalidateQueries(\n    queryKey?: QueryKey,\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKey | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const refetchFilters: QueryFilters = {\n      ...filters,\n      active: filters.refetchActive ?? true,\n      inactive: filters.refetchInactive ?? false,\n    }\n\n    return notifyManager.batch(() => {\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries(\n    filters?: QueryFilters,\n    options?: RefetchOptions\n  ): Promise<void>\n  refetchQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: RefetchOptions\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | RefetchOptions,\n    arg3?: RefetchOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache.findAll(filters).map(query => query.fetch())\n    )\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    options: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData>\n  fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryKey: QueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData>\n  fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TQueryFnData>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData>\n  fetchQuery<TQueryFnData, TError, TData = TQueryFnData>(\n    arg1: QueryKey | FetchQueryOptions<TQueryFnData, TError, TData>,\n    arg2?:\n      | QueryFunction<TQueryFnData>\n      | FetchQueryOptions<TQueryFnData, TError, TData>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery(options: FetchQueryOptions): Promise<void>\n  prefetchQuery(queryKey: QueryKey, options?: FetchQueryOptions): Promise<void>\n  prefetchQuery(\n    queryKey: QueryKey,\n    queryFn: QueryFunction,\n    options?: FetchQueryOptions\n  ): Promise<void>\n  prefetchQuery(\n    arg1: QueryKey | FetchQueryOptions,\n    arg2?: QueryFunction | FetchQueryOptions,\n    arg3?: FetchQueryOptions\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData\n  >(\n    queryKey: QueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData\n  >(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TQueryFnData>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<TQueryFnData, TError, TData = TQueryFnData>(\n    arg1: QueryKey | FetchInfiniteQueryOptions<TQueryFnData, TError, TData>,\n    arg2?:\n      | QueryFunction<TQueryFnData>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery(options: FetchInfiniteQueryOptions): Promise<void>\n  prefetchInfiniteQuery(\n    queryKey: QueryKey,\n    options?: FetchInfiniteQueryOptions\n  ): Promise<void>\n  prefetchInfiniteQuery(\n    queryKey: QueryKey,\n    queryFn: QueryFunction,\n    options?: FetchInfiniteQueryOptions\n  ): Promise<void>\n  prefetchInfiniteQuery(\n    arg1: QueryKey | FetchInfiniteQueryOptions,\n    arg2?: QueryFunction | FetchInfiniteQueryOptions,\n    arg3?: FetchInfiniteQueryOptions\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  cancelMutations(): Promise<void> {\n    const promises = notifyManager.batch(() =>\n      this.mutationCache.getAll().map(mutation => mutation.cancel())\n    )\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  resumePausedMutations(): Promise<void> {\n    return this.getMutationCache().resumePausedMutations()\n  }\n\n  executeMutation<\n    TData = unknown,\n    TError = unknown,\n    TVariables = void,\n    TContext = unknown\n  >(\n    options: MutationOptions<TData, TError, TVariables, TContext>\n  ): Promise<TData> {\n    return this.mutationCache.build(this, options).execute()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<any, any, any, any>\n  ): void {\n    const result = this.queryDefaults.find(\n      x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey)\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey\n  ): QueryObserverOptions<any, any, any, any> | undefined {\n    return queryKey\n      ? this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey))\n          ?.defaultOptions\n      : undefined\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>\n  ): void {\n    const result = this.mutationDefaults.find(\n      x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey)\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    return mutationKey\n      ? this.mutationDefaults.find(x =>\n          partialMatchKey(mutationKey, x.mutationKey)\n        )?.defaultOptions\n      : undefined\n  }\n\n  defaultQueryOptions<T extends QueryOptions<any, any, any>>(options?: T): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  defaultQueryObserverOptions<\n    T extends QueryObserverOptions<any, any, any, any>\n  >(options?: T): T {\n    return this.defaultQueryOptions(options)\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n","import {\n  getStatusProps,\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceEqualDeep,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  PlaceholderDataFunction,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n  ResultOptions,\n} from './types'\nimport type { Query, QueryState, Action, FetchOptions } from './query'\nimport type { QueryClient } from './queryClient'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>\n) => void\n\ninterface NotifyOptions {\n  cache?: boolean\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private initialDataUpdateCount: number\n  private initialErrorUpdateCount: number\n  private staleTimeoutId?: number\n  private refetchIntervalId?: number\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.initialDataUpdateCount = 0\n    this.initialErrorUpdateCount = 0\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.updateQuery()\n\n      this.currentQuery.addObserver(this)\n\n      if (this.willFetchOnMount()) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  willLoadOnMount(): boolean {\n    return (\n      this.options.enabled !== false &&\n      !this.currentQuery.state.dataUpdatedAt &&\n      !(\n        this.currentQuery.state.status === 'error' &&\n        this.options.retryOnMount === false\n      )\n    )\n  }\n\n  willRefetchOnMount(): boolean {\n    return (\n      this.options.enabled !== false &&\n      this.currentQuery.state.dataUpdatedAt > 0 &&\n      (this.options.refetchOnMount === 'always' ||\n        (this.options.refetchOnMount !== false && this.isStale()))\n    )\n  }\n\n  willFetchOnMount(): boolean {\n    return this.willLoadOnMount() || this.willRefetchOnMount()\n  }\n\n  willFetchOnReconnect(): boolean {\n    return (\n      this.options.enabled !== false &&\n      (this.options.refetchOnReconnect === 'always' ||\n        (this.options.refetchOnReconnect !== false && this.isStale()))\n    )\n  }\n\n  willFetchOnWindowFocus(): boolean {\n    return (\n      this.options.enabled !== false &&\n      (this.options.refetchOnWindowFocus === 'always' ||\n        (this.options.refetchOnWindowFocus !== false && this.isStale()))\n    )\n  }\n\n  private willFetchOptionally(): boolean {\n    return this.options.enabled !== false && this.isStale()\n  }\n\n  private isStale(): boolean {\n    return this.currentQuery.isStaleByTime(this.options.staleTime)\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.clearTimers()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryObserverOptions(options)\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    // Take no further actions if there are no subscribers\n    if (!this.listeners.length) {\n      return\n    }\n\n    // If we subscribed to a new query, optionally fetch and update refetch\n    if (this.currentQuery !== prevQuery) {\n      this.optionalFetch()\n      this.updateTimers()\n      return\n    }\n\n    // Optionally fetch if the query became enabled\n    if (this.options.enabled !== false && prevOptions.enabled === false) {\n      this.optionalFetch()\n    }\n\n    // Update stale interval if needed\n    if (\n      this.options.enabled !== prevOptions.enabled ||\n      this.options.staleTime !== prevOptions.staleTime\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    // Update refetch interval if needed\n    if (\n      this.options.enabled !== prevOptions.enabled ||\n      this.options.refetchInterval !== prevOptions.refetchInterval\n    ) {\n      this.updateRefetchInterval()\n    }\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  getNextResult(\n    options?: ResultOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return new Promise((resolve, reject) => {\n      const unsubscribe = this.subscribe(result => {\n        if (!result.isFetching) {\n          unsubscribe()\n          if (result.isError && options?.throwOnError) {\n            reject(result.error)\n          } else {\n            resolve(result)\n          }\n        }\n      })\n    })\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch(\n    options?: RefetchOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.fetch(options)\n  }\n\n  protected fetch(\n    fetchOptions?: ObserverFetchOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch(fetchOptions).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private optionalFetch(): void {\n    if (this.willFetchOptionally()) {\n      this.executeFetch()\n    }\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData>,\n      fetchOptions\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        const prevResult = this.currentResult\n        this.updateResult()\n        this.notify({\n          listeners: this.shouldNotifyListeners(prevResult, this.currentResult),\n          cache: true,\n        })\n      }\n    }, timeout)\n  }\n\n  private updateRefetchInterval(): void {\n    this.clearRefetchInterval()\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.options.refetchInterval)\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.options.refetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval()\n  }\n\n  private clearTimers(): void {\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n  }\n\n  private clearStaleTimeout(): void {\n    clearTimeout(this.staleTimeoutId)\n    this.staleTimeoutId = undefined\n  }\n\n  private clearRefetchInterval(): void {\n    clearInterval(this.refetchIntervalId)\n    this.refetchIntervalId = undefined\n  }\n\n  protected getNewResult(\n    willFetch?: boolean\n  ): QueryObserverResult<TData, TError> {\n    const { state } = this.currentQuery\n    let { isFetching, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n    let dataUpdatedAt = state.dataUpdatedAt\n\n    // Optimistically set status to loading if we will start fetching\n    if (willFetch) {\n      isFetching = true\n      if (!dataUpdatedAt) {\n        status = 'loading'\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      this.options.keepPreviousData &&\n      !state.dataUpdateCount &&\n      this.previousQueryResult?.isSuccess\n    ) {\n      data = this.previousQueryResult.data\n      dataUpdatedAt = this.previousQueryResult.dataUpdatedAt\n      status = this.previousQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (this.options.select && typeof state.data !== 'undefined') {\n      // Use the previous select result if the query data did not change\n      if (this.currentResult && state.data === this.currentResultState?.data) {\n        data = this.currentResult.data\n      } else {\n        data = this.options.select(state.data)\n        if (this.options.structuralSharing !== false) {\n          data = replaceEqualDeep(this.currentResult?.data, data)\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = (state.data as unknown) as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof this.options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      const placeholderData =\n        typeof this.options.placeholderData === 'function'\n          ? (this.options.placeholderData as PlaceholderDataFunction<TData>)()\n          : this.options.placeholderData\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = placeholderData\n        isPlaceholderData = true\n      }\n    }\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      ...getStatusProps(status),\n      data,\n      dataUpdatedAt,\n      error: state.error,\n      errorUpdatedAt: state.errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > this.initialDataUpdateCount ||\n        state.errorUpdateCount > this.initialErrorUpdateCount,\n      isFetching,\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: this.isStale(),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  private shouldNotifyListeners(\n    prevResult: QueryObserverResult,\n    result: QueryObserverResult\n  ): boolean {\n    const { notifyOnChangeProps, notifyOnChangePropsExclusions } = this.options\n\n    if (prevResult === result) {\n      return false\n    }\n\n    if (!notifyOnChangeProps && !notifyOnChangePropsExclusions) {\n      return true\n    }\n\n    const keys = Object.keys(result)\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i] as keyof QueryObserverResult\n      const changed = prevResult[key] !== result[key]\n      const isIncluded = notifyOnChangeProps?.some(x => x === key)\n      const isExcluded = notifyOnChangePropsExclusions?.some(x => x === key)\n\n      if (changed) {\n        if (notifyOnChangePropsExclusions && isExcluded) {\n          continue\n        }\n\n        if (!notifyOnChangeProps || isIncluded) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  private updateResult(willFetch?: boolean): void {\n    const result = this.getNewResult(willFetch)\n\n    // Keep reference to the current state on which the current result is based on\n    this.currentResultState = this.currentQuery.state\n\n    // Only update if something has changed\n    if (!shallowEqualObjects(result, this.currentResult)) {\n      this.currentResult = result\n    }\n  }\n\n  private updateQuery(): void {\n    const prevQuery = this.currentQuery\n\n    const query = this.client\n      .getQueryCache()\n      .build(\n        this.client,\n        this.options as QueryOptions<TQueryFnData, TError, TQueryData>\n      )\n\n    if (query === prevQuery) {\n      return\n    }\n\n    this.previousQueryResult = this.currentResult\n    this.currentQuery = query\n    this.initialDataUpdateCount = query.state.dataUpdateCount\n    this.initialErrorUpdateCount = query.state.errorUpdateCount\n\n    const willFetch = prevQuery\n      ? this.willFetchOptionally()\n      : this.willFetchOnMount()\n\n    this.updateResult(willFetch)\n\n    if (!this.hasListeners()) {\n      return\n    }\n\n    prevQuery?.removeObserver(this)\n    this.currentQuery.addObserver(this)\n\n    if (\n      this.shouldNotifyListeners(this.previousQueryResult, this.currentResult)\n    ) {\n      this.notify({ listeners: true })\n    }\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    // Store current result and get new result\n    const prevResult = this.currentResult\n    this.updateResult()\n    const currentResult = this.currentResult\n\n    // Update timers\n    this.updateTimers()\n\n    // Do not notify if the nothing has changed\n    if (prevResult === currentResult) {\n      return\n    }\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    if (this.shouldNotifyListeners(prevResult, currentResult)) {\n      notifyOptions.listeners = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        this.options.onSuccess?.(this.currentResult.data!)\n        this.options.onSettled?.(this.currentResult.data!, null)\n      } else if (notifyOptions.onError) {\n        this.options.onError?.(this.currentResult.error!)\n        this.options.onSettled?.(undefined, this.currentResult.error!)\n      }\n\n      // Then trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify(this.currentQuery)\n      }\n    })\n  }\n}\n","import { difference, getQueryKeyHashFn, replaceAt } from './utils'\nimport { notifyManager } from './notifyManager'\nimport type { QueryObserverOptions, QueryObserverResult } from './types'\nimport type { QueryClient } from './queryClient'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\n\ntype QueriesObserverListener = (result: QueryObserverResult[]) => void\n\nexport class QueriesObserver extends Subscribable<QueriesObserverListener> {\n  private client: QueryClient\n  private result: QueryObserverResult[]\n  private queries: QueryObserverOptions[]\n  private observers: QueryObserver[]\n\n  constructor(client: QueryClient, queries?: QueryObserverOptions[]) {\n    super()\n\n    this.client = client\n    this.queries = queries || []\n    this.result = []\n    this.observers = []\n\n    // Subscribe to queries\n    this.updateObservers()\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.observers.forEach(observer => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(queries: QueryObserverOptions[]): void {\n    this.queries = queries\n    this.updateObservers()\n  }\n\n  getCurrentResult(): QueryObserverResult[] {\n    return this.result\n  }\n\n  private updateObservers(): void {\n    let hasIndexChange = false\n\n    const prevObservers = this.observers\n    const newObservers = this.queries.map((options, i) => {\n      let observer: QueryObserver | undefined = prevObservers[i]\n\n      const defaultedOptions = this.client.defaultQueryObserverOptions(options)\n      const hashFn = getQueryKeyHashFn(defaultedOptions)\n      defaultedOptions.queryHash = hashFn(defaultedOptions.queryKey!)\n\n      if (\n        !observer ||\n        observer.getCurrentQuery().queryHash !== defaultedOptions.queryHash\n      ) {\n        hasIndexChange = true\n        observer = prevObservers.find(\n          x => x.getCurrentQuery().queryHash === defaultedOptions.queryHash\n        )\n      }\n\n      if (observer) {\n        observer.setOptions(defaultedOptions)\n        return observer\n      }\n\n      return new QueryObserver(this.client, defaultedOptions)\n    })\n\n    if (prevObservers.length === newObservers.length && !hasIndexChange) {\n      return\n    }\n\n    this.observers = newObservers\n    this.result = newObservers.map(observer => observer.getCurrentResult())\n\n    if (!this.listeners.length) {\n      return\n    }\n\n    difference(prevObservers, newObservers).forEach(observer => {\n      observer.destroy()\n    })\n\n    difference(newObservers, prevObservers).forEach(observer => {\n      observer.subscribe(result => {\n        this.onUpdate(observer, result)\n      })\n    })\n\n    this.notify()\n  }\n\n  private onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result)\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result)\n      })\n    })\n  }\n}\n","import type {\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport { ObserverFetchOptions, QueryObserver } from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  InfiniteData<TData>,\n  InfiniteData<TQueryData>\n> {\n  // Type override\n  subscribe!: (\n    listener?: InfiniteQueryObserverListener<TData, TError>\n  ) => () => void\n\n  // Type override\n  getCurrentResult!: () => InfiniteQueryObserverResult<TData, TError>\n\n  // Type override\n  protected fetch!: (\n    fetchOptions?: ObserverFetchOptions\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options?: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >\n  ): void {\n    super.setOptions({\n      ...options,\n      behavior: infiniteQueryBehavior<TQueryFnData, TError, TData>(),\n    })\n  }\n\n  fetchNextPage(\n    options?: FetchNextPageOptions\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      cancelRefetch: true,\n      throwOnError: options?.throwOnError,\n      meta: {\n        fetchMore: { direction: 'forward', pageParam: options?.pageParam },\n      },\n    })\n  }\n\n  fetchPreviousPage(\n    options?: FetchPreviousPageOptions\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      cancelRefetch: true,\n      throwOnError: options?.throwOnError,\n      meta: {\n        fetchMore: { direction: 'backward', pageParam: options?.pageParam },\n      },\n    })\n  }\n\n  protected getNewResult(\n    willFetch?: boolean\n  ): InfiniteQueryObserverResult<TData, TError> {\n    const { state } = this.getCurrentQuery()\n    const result = super.getNewResult(willFetch)\n    return {\n      ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(this.options, state.data?.pages),\n      hasPreviousPage: hasPreviousPage(this.options, state.data?.pages),\n      isFetchingNextPage:\n        state.isFetching && state.fetchMeta?.fetchMore?.direction === 'forward',\n      isFetchingPreviousPage:\n        state.isFetching &&\n        state.fetchMeta?.fetchMore?.direction === 'backward',\n    }\n  }\n}\n","import { Action, getDefaultState, Mutation } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type {\n  MutateOptions,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from './types'\nimport { getStatusProps } from './utils'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>\n  ) {\n    this.options = this.client.defaultMutationOptions(options)\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables: variables ?? this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.currentResult = {\n      ...state,\n      ...getStatusProps(state.status),\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n  }\n\n  private notify(options: NotifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          this.mutateOptions.onSuccess?.(\n            this.currentResult.data!,\n            this.currentResult.variables!,\n            this.currentResult.context!\n          )\n          this.mutateOptions.onSettled?.(\n            this.currentResult.data!,\n            null,\n            this.currentResult.variables!,\n            this.currentResult.context\n          )\n        } else if (options.onError) {\n          this.mutateOptions.onError?.(\n            this.currentResult.error!,\n            this.currentResult.variables!,\n            this.currentResult.context\n          )\n          this.mutateOptions.onSettled?.(\n            undefined,\n            this.currentResult.error,\n            this.currentResult.variables!,\n            this.currentResult.context\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      if (options.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult)\n        })\n      }\n    })\n  }\n}\n"],"names":["_inheritsLoose","subClass","superClass","prototype","Object","create","constructor","__proto__","_extends","assign","target","i","arguments","length","source","key","hasOwnProperty","call","apply","this","isServer","window","noop","functionalUpdate","updater","input","isValidTimeout","value","Infinity","ensureArray","Array","isArray","difference","array1","array2","filter","x","indexOf","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseFilterArgs","matchQuery","filters","query","isActive","active","exact","fetching","inactive","predicate","stale","hashFn","getQueryKeyHashFn","options","queryHash","partialMatchKey","isStale","isFetching","queryKeyHashFn","hashQueryKey","JSON","stringify","_","val","isPlainObject","keys","sort","reduce","result","a","b","partialDeepEqual","some","replaceEqualDeep","array","aSize","bItems","bSize","copy","equalItems","o","hasObjectPrototype","ctor","prot","toString","getStatusProps","status","isLoading","isSuccess","isError","isIdle","scheduleMicrotask","callback","Promise","resolve","then","catch","error","setTimeout","notifyManager","queue","transactions","notifyFn","batchNotifyFn","batch","flush","schedule","push","_this","batchCalls","args","_this2","_this3","forEach","setNotifyFunction","fn","setBatchNotifyFunction","logger","console","warn","log","getLogger","Subscribable","listeners","subscribe","listener","onSubscribe","onUnsubscribe","hasListeners","focusManager","removeEventListener","setDefaultEventListener","setEventListener","setup","focused","setFocused","onFocus","isFocused","document","undefined","includes","visibilityState","_window","addEventListener","onlineManager","online","setOnline","onOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","isCancelable","cancel","CancelledError","revert","silent","isCancelledError","Retryer","config","cancelFn","continueFn","promiseResolve","promiseReject","cancelRetry","cancelOptions","continue","isPaused","isResolved","isTransportCancelable","promise","outerResolve","outerReject","reject","run","promiseOrValue","timeout","retry","delay","retryDelay","shouldRetry","onFail","continueResolve","onPause","onContinue","Query","defaultOptions","setOptions","observers","cache","initialState","state","getDefaultState","scheduleGc","cacheTime","setDefaultOptions","clearGcTimeout","gcTimeout","optionalRemove","clearTimeout","remove","setData","prevData","data","isDataEqual","_this$options$isDataE","structuralSharing","dispatch","type","dataUpdatedAt","setState","retryer","destroy","reset","observer","enabled","isInvalidated","getCurrentResult","isStaleByTime","find","willFetchOnWindowFocus","refetch","willFetchOnReconnect","addObserver","notify","removeObserver","invalidate","fetch","fetchOptions","cancelRefetch","queryFnContext","pageParam","context","fetchFn","behavior","_this$options$behavio","onFetch","fetchMeta","_context$fetchOptions","meta","_context$fetchOptions2","onError","action","reducer","onQueryUpdate","initialData","initialDataUpdatedAt","hasData","dataUpdateCount","errorUpdateCount","errorUpdatedAt","fetchFailureCount","QueryCache","queries","queriesMap","build","client","get","defaultQueryOptions","getQueryDefaults","add","queryInMap","clear","getAll","findAll","_this4","_this5","Mutation","mutationId","mutationCache","execute","restored","variables","onMutate","executeMutation","onSuccess","onSettled","mutationFn","onMutationUpdate","MutationCache","mutations","mutation","defaultMutationOptions","mutationKey","getMutationDefaults","resumePausedMutations","pausedMutations","infiniteQueryBehavior","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","fetchPage","manual","param","previous","queryFnResult","page","getNextPageParam","getPreviousPageParam","finalPromise","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryClient","queryCache","queryDefaults","mutationDefaults","mount","unsubscribeFocus","unsubscribeOnline","unmount","getQueryData","_this$queryCache$find","setQueryData","parsedOptions","defaultedOptions","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","map","all","invalidateQueries","refetchActive","refetchInactive","throwOnError","fetchQuery","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","cancelMutations","_this6","getMutationCache","getQueryCache","getDefaultOptions","setQueryDefaults","_this$queryDefaults$f","setMutationDefaults","_this$mutationDefault","_defaulted","defaultQueryObserverOptions","QueryObserver","initialDataUpdateCount","initialErrorUpdateCount","bindMethods","bind","updateQuery","currentQuery","willFetchOnMount","executeFetch","updateTimers","willLoadOnMount","retryOnMount","willRefetchOnMount","refetchOnMount","refetchOnReconnect","refetchOnWindowFocus","willFetchOptionally","clearTimers","prevOptions","prevQuery","Error","optionalFetch","updateStaleTimeout","refetchInterval","updateRefetchInterval","currentResult","getNextResult","unsubscribe","getCurrentQuery","updateResult","clearStaleTimeout","staleTimeoutId","prevResult","shouldNotifyListeners","clearRefetchInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","getNewResult","willFetch","isPreviousData","isPlaceholderData","keepPreviousData","previousQueryResult","_this$previousQueryRe","select","currentResultState","_this$currentResultSt","_this$currentResult","placeholderData","isFetched","isFetchedAfterMount","isLoadingError","isRefetchError","notifyOnChangeProps","notifyOnChangePropsExclusions","changed","isIncluded","isExcluded","shallowEqualObjects","notifyOptions","QueriesObserver","updateObservers","onUpdate","setQueries","hasIndexChange","prevObservers","newObservers","index","slice","replaceAt","InfiniteQueryObserver","_QueryObserver","fetchNextPage","fetchPreviousPage","_state$data","_state$data2","MutationObserver","mutate","currentMutation","mutateOptions","newLogger"],"mappings":"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"}