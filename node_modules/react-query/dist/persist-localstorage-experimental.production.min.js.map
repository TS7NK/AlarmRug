{"version":3,"file":"persist-localstorage-experimental.production.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../src/hydration/hydration.ts","../src/persist-localstorage-experimental/index.ts"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import type { QueryClient } from '../core/queryClient'\nimport type { Query, QueryState } from '../core/query'\nimport type {\n  MutationKey,\n  MutationOptions,\n  QueryKey,\n  QueryOptions,\n} from '../core/types'\nimport type { Mutation, MutationState } from '../core/mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  dehydrateMutations?: boolean\n  dehydrateQueries?: boolean\n  shouldDehydrateMutation?: ShouldDehydrateMutationFunction\n  shouldDehydrateQuery?: ShouldDehydrateQueryFunction\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport interface DehydratedState {\n  mutations: DehydratedMutation[]\n  queries: DehydratedQuery[]\n}\n\nexport type ShouldDehydrateQueryFunction = (query: Query) => boolean\n\nexport type ShouldDehydrateMutationFunction = (mutation: Mutation) => boolean\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n  }\n}\n\nfunction defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nfunction defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options?: DehydrateOptions\n): DehydratedState {\n  options = options || {}\n\n  const mutations: DehydratedMutation[] = []\n  const queries: DehydratedQuery[] = []\n\n  if (options?.dehydrateMutations !== false) {\n    const shouldDehydrateMutation =\n      options.shouldDehydrateMutation || defaultShouldDehydrateMutation\n\n    client\n      .getMutationCache()\n      .getAll()\n      .forEach(mutation => {\n        if (shouldDehydrateMutation(mutation)) {\n          mutations.push(dehydrateMutation(mutation))\n        }\n      })\n  }\n\n  if (options?.dehydrateQueries !== false) {\n    const shouldDehydrateQuery =\n      options.shouldDehydrateQuery || defaultShouldDehydrateQuery\n\n    client\n      .getQueryCache()\n      .getAll()\n      .forEach(query => {\n        if (shouldDehydrateQuery(query)) {\n          queries.push(dehydrateQuery(query))\n        }\n      })\n  }\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach(dehydratedMutation => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n      },\n      dehydratedMutation.state\n    )\n  })\n\n  queries.forEach(dehydratedQuery => {\n    const query = queryCache.get(dehydratedQuery.queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey: dehydratedQuery.queryKey,\n        queryHash: dehydratedQuery.queryHash,\n      },\n      dehydratedQuery.state\n    )\n  })\n}\n","import { QueryClient } from '../core'\nimport { dehydrate, hydrate } from '../hydration'\n\ninterface LocalStorageCache {\n  timestamp: number\n  buster: string\n  cacheState: any\n}\n\ninterface Options {\n  /** The key to use when storing the cache to localstorage */\n  localStorageKey?: string\n  /** To avoid localstorage spamming,\n   * pass a time in ms to throttle saving the cache to disk */\n  throttleTime?: number\n  /** The max-allowed age of the cache.\n   * If a persisted cache is found that is older than this\n   * time, it will be discarded */\n  maxAge?: number\n  /** A unique string that can be used to forcefully\n   * invalidate existing caches if they do not share the same buster string */\n  buster?: string\n}\n\nexport function persistWithLocalStorage(\n  queryClient: QueryClient,\n  {\n    localStorageKey = `REACT_QUERY_OFFLINE_CACHE`,\n    throttleTime = 1000,\n    maxAge = 1000 * 60 * 60 * 24,\n    buster = '',\n  }: Options = {}\n) {\n  if (typeof window !== 'undefined') {\n    // Subscribe to changes\n    const saveCache = throttle(() => {\n      const storageCache: LocalStorageCache = {\n        buster,\n        timestamp: Date.now(),\n        cacheState: dehydrate(queryClient),\n      }\n\n      localStorage.setItem(localStorageKey, JSON.stringify(storageCache))\n    }, throttleTime)\n\n    queryClient.getQueryCache().subscribe(saveCache)\n\n    // Attempt restore\n    const cacheStorage = localStorage.getItem(localStorageKey)\n\n    if (!cacheStorage) {\n      return\n    }\n\n    const cache: LocalStorageCache = JSON.parse(cacheStorage)\n\n    if (cache.timestamp) {\n      const expired = Date.now() - cache.timestamp > maxAge\n      const busted = cache.buster !== buster\n      if (expired || busted) {\n        localStorage.removeItem(localStorageKey)\n      } else {\n        hydrate(queryClient, cache.cacheState)\n      }\n    } else {\n      localStorage.removeItem(localStorageKey)\n    }\n  }\n}\n\nfunction throttle(func: (...args: any[]) => any, wait = 100) {\n  let timer: number | null = null\n\n  return function (...args: any[]) {\n    if (timer === null) {\n      timer = setTimeout(() => {\n        func(...args)\n        timer = null\n      }, wait)\n    }\n  }\n}\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","defaultShouldDehydrateMutation","mutation","state","isPaused","defaultShouldDehydrateQuery","query","status","dehydrate","client","options","mutations","queries","dehydrateMutations","shouldDehydrateMutation","getMutationCache","getAll","forEach","push","mutationKey","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","getQueryCache","queryKey","queryHash","dehydrateQuery","queryClient","localStorageKey","throttleTime","maxAge","buster","window","saveCache","func","wait","timer","args","setTimeout","throttle","storageCache","timestamp","Date","now","cacheState","localStorage","setItem","JSON","stringify","subscribe","cacheStorage","getItem","cache","parse","expired","busted","removeItem","dehydratedState","mutationCache","queryCache","dehydratedMutation","build","defaultOptions","_options$defaultOptio","dehydratedQuery","get","dataUpdatedAt","setState","_options$defaultOptio2","hydrate"],"mappings":"uOAAe,SAASA,WACtBA,EAAWC,OAAOC,QAAU,SAAUC,OAC/B,IAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,KACrCG,EAASF,UAAUD,OAElB,IAAII,KAAOD,EACVN,OAAOQ,UAAUC,eAAeC,KAAKJ,EAAQC,KAC/CL,EAAOK,GAAOD,EAAOC,WAKpBL,IAGOS,MAAMC,KAAMR,WCoD9B,SAASS,EAA+BC,UAC/BA,EAASC,MAAMC,SAGxB,SAASC,EAA4BC,SACL,YAAvBA,EAAMH,MAAMI,OAGd,SAASC,EACdC,EACAC,WAIMC,EAAkC,GAClCC,EAA6B,OAEC,cALpCF,EAAUA,GAAW,aAKRG,oBAA8B,KACnCC,EACJJ,EAAQI,yBAA2Bb,EAErCQ,EACGM,mBACAC,SACAC,SAAQ,SAAAf,GACHY,EAAwBZ,IAC1BS,EAAUO,KA7CpB,SAA2BhB,SAClB,CACLiB,YAAajB,EAASQ,QAAQS,YAC9BhB,MAAOD,EAASC,OA0CKiB,CAAkBlB,WAKP,cAA9BQ,YAASW,kBAA4B,KACjCC,EACJZ,EAAQY,sBAAwBjB,EAElCI,EACGc,gBACAP,SACAC,SAAQ,SAAAX,GACHgB,EAAqBhB,IACvBM,EAAQM,KAhDlB,SAAwBZ,SACf,CACLH,MAAOG,EAAMH,MACbqB,SAAUlB,EAAMkB,SAChBC,UAAWnB,EAAMmB,WA4CEC,CAAepB,aAK7B,CAAEK,UAAAA,EAAWC,QAAAA,6BCxFf,SACLe,sBAMa,SAJXC,gBAAAA,+CACAC,aAAAA,aAAe,UACfC,OAAAA,aAAS,YACTC,OAAAA,aAAS,QAGW,oBAAXC,OAAwB,KAE3BC,EAmCV,SAAkBC,EAA+BC,YAAAA,IAAAA,EAAO,SAClDC,EAAuB,YAEpB,sCAAaC,2BAAAA,kBACJ,OAAVD,IACFA,EAAQE,YAAW,WACjBJ,eAAQG,GACRD,EAAQ,OACPD,KA3CaI,EAAS,eACnBC,EAAkC,CACtCT,OAAAA,EACAU,UAAWC,KAAKC,MAChBC,WAAYpC,EAAUmB,IAGxBkB,aAAaC,QAAQlB,EAAiBmB,KAAKC,UAAUR,MACpDX,GAEHF,EAAYJ,gBAAgB0B,UAAUhB,OAGhCiB,EAAeL,aAAaM,QAAQvB,OAErCsB,aAICE,EAA2BL,KAAKM,MAAMH,MAExCE,EAAMX,UAAW,KACba,EAAUZ,KAAKC,MAAQS,EAAMX,UAAYX,EACzCyB,EAASH,EAAMrB,SAAWA,EAC5BuB,GAAWC,EACbV,aAAaW,WAAW5B,GDuDzB,SACLnB,EACAgD,EACA/C,MAE+B,iBAApB+C,GAAoD,OAApBA,OAIrCC,EAAgBjD,EAAOM,mBACvB4C,EAAalD,EAAOc,gBAEpBZ,EAAa8C,EAAoC9C,WAAa,GAC9DC,EAAW6C,EAAoC7C,SAAW,GAEhED,EAAUM,SAAQ,SAAA2C,SAChBF,EAAcG,MACZpD,aAEKC,YAAAA,EAASoD,uBAATC,EAAyBpD,WAC5BQ,YAAayC,EAAmBzC,cAElCyC,EAAmBzD,UAIvBS,EAAQK,SAAQ,SAAA+C,SACR1D,EAAQqD,EAAWM,IAAID,EAAgBvC,WAGzCnB,EACEA,EAAMH,MAAM+D,cAAgBF,EAAgB7D,MAAM+D,eACpD5D,EAAM6D,SAASH,EAAgB7D,OAMnCwD,EAAWE,MACTpD,aAEKC,YAAAA,EAASoD,uBAATM,EAAyBxD,SAC5BY,SAAUwC,EAAgBxC,SAC1BC,UAAWuC,EAAgBvC,YAE7BuC,EAAgB7D,WClGdkE,CAAQ1C,EAAayB,EAAMR,iBAG7BC,aAAaW,WAAW5B"}