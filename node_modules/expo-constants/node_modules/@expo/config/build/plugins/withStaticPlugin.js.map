{"version":3,"file":"withStaticPlugin.js","sourceRoot":"","sources":["../../src/plugins/withStaticPlugin.ts"],"names":[],"mappings":";;AACA,sCAAgD;AAChD,iEAKgC;AAEhC;;;;;;GAMG;AACU,QAAA,gBAAgB,GAIxB,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;;IACrB,IAAI,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC;IACpC,IAAI,CAAC,WAAW,EAAE;QAChB,WAAW,SAAG,MAAM,CAAC,SAAS,0CAAE,WAAW,CAAC;QAC5C,gDAAyB,CAAC,WAAW,CAAC,CAAC;KACxC;IAED,IAAI,CAAC,aAAa,EAAE,WAAW,CAAC,GAAG,4CAAqB,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IACvE,gDAAgD;IAChD,eAAM,CACJ,EAAC,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,cAAc,CAAA,EAC5B,iFAAiF,CAClF,CAAC;IAEF,IAAI,UAAiC,CAAC;IACtC,8DAA8D;IAC9D,IAAI,OAAO,aAAa,KAAK,UAAU,EAAE;QACvC,UAAU,GAAG,aAAa,CAAC;KAC5B;SAAM,IAAI,OAAO,aAAa,KAAK,QAAQ,EAAE;QAC5C,IAAI;YACF,gCAAgC;YAChC,UAAU,GAAG,kDAA2B,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;SACtE;QAAC,OAAO,KAAK,EAAE;YACd,qEAAqE;YACrE,gGAAgG;YAChG,IAAI,KAAK,CAAC,QAAQ,EAAE;gBAClB,IAAI,CAAC,WAAW;oBAAE,WAAW,GAAG,EAAE,CAAC;gBACnC,wGAAwG;gBACxG,WAAW,CAAC,cAAc,GAAG,KAAK,CAAC;gBACnC,UAAU,GAAG,KAAK,CAAC,QAAQ,CAAC;aAC7B;iBAAM;gBACL,8CAA8C;gBAC9C,MAAM,KAAK,CAAC;aACb;SACF;KACF;SAAM;QACL,MAAM,IAAI,oBAAW,CACnB,wCAAwC,OAAO,aAAa,EAAE,EAC9D,gBAAgB,CACjB,CAAC;KACH;IACD,sBAAsB;IACtB,MAAM,GAAG,UAAU,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;IACzC,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC","sourcesContent":["import { ConfigPlugin } from '../Config.types';\nimport { assert, ConfigError } from '../Errors';\nimport {\n  assertInternalProjectRoot,\n  normalizeStaticPlugin,\n  resolveConfigPluginFunction,\n  StaticPlugin,\n} from './modulePluginResolver';\n\n/**\n * Resolves static module plugin and potentially falls back on a provided plugin if the module cannot be resolved\n *\n * @param config\n * @param fallback Plugin with `_resolverError` explaining why the module couldn't be used\n * @param projectRoot optional project root, fallback to _internal.projectRoot. Used for testing.\n */\nexport const withStaticPlugin: ConfigPlugin<{\n  plugin: StaticPlugin | string;\n  fallback?: ConfigPlugin<{ _resolverError: Error } & any>;\n  projectRoot?: string;\n}> = (config, props) => {\n  let projectRoot = props.projectRoot;\n  if (!projectRoot) {\n    projectRoot = config._internal?.projectRoot;\n    assertInternalProjectRoot(projectRoot);\n  }\n\n  let [pluginResolve, pluginProps] = normalizeStaticPlugin(props.plugin);\n  // Ensure no one uses this property by accident.\n  assert(\n    !pluginProps?._resolverError,\n    `Plugin property '_resolverError' is a reserved property of \\`withStaticPlugin\\``\n  );\n\n  let withPlugin: ConfigPlugin<unknown>;\n  // Function was provided, no need to resolve: [withPlugin, {}]\n  if (typeof pluginResolve === 'function') {\n    withPlugin = pluginResolve;\n  } else if (typeof pluginResolve === 'string') {\n    try {\n      // Resolve and evaluate plugins.\n      withPlugin = resolveConfigPluginFunction(projectRoot, pluginResolve);\n    } catch (error) {\n      // If the static module failed to resolve, attempt to use a fallback.\n      // This enables support for built-in plugins with versioned variations living in other packages.\n      if (props.fallback) {\n        if (!pluginProps) pluginProps = {};\n        // Pass this to the fallback plugin for potential warnings about needing to install a versioned package.\n        pluginProps._resolverError = error;\n        withPlugin = props.fallback;\n      } else {\n        // If no fallback, throw the resolution error.\n        throw error;\n      }\n    }\n  } else {\n    throw new ConfigError(\n      `Static plugin is an unexpected type: ${typeof pluginResolve}`,\n      'INVALID_PLUGIN'\n    );\n  }\n  // Execute the plugin.\n  config = withPlugin(config, pluginProps);\n  return config;\n};\n"]}